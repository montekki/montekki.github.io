<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>The GKR Protocol</title>



<meta property="og:title" content="The GKR Protocol">



<meta name="author" content="Fedor Sakharov">


<meta property="og:locale" content="en_US">




<link rel="canonical" href="https://montekki.github.io/thaler-ch4-4/">
<meta property="og:url" content="https://montekki.github.io/thaler-ch4-4/">





  <meta property="og:image" content="https://montekki.github.io/assets/favicon.jpg">
  
  



  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2022-12-06T00:00:00+00:00">







  <meta name="twitter:card" content="summary_large_image"">
  <meta property="twitter:image" content="https://montekki.github.io/assets/favicon.jpg">



  <meta property="twitter:title" content="The GKR Protocol">



  <meta name="twitter:site" content="@m0nt3kk1">
  






<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"Fedor Sakharov"
  },
  "description": "",
  "url": "https://montekki.github.io/thaler-ch4-4/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "The GKR Protocol"
  
    
    
      "datePublished":"2022-12-06T00:00:00+00:00",
    
    ,
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://montekki.github.io/thaler-ch4-4/"
    }
  
}
</script>

  <link rel="stylesheet" href="https://montekki.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://montekki.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://montekki.github.io/assets/favicon-16x16.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://montekki.github.io/atom.xml" title="" />
  

  

  
  

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
                                                                                                                                                                                                            <script>


        document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
    </script>


</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://montekki.github.io">
        <h2 class="nav-title"></h2>
      </a>
      <ul>
        
          
            <li><a href="https://montekki.github.io">Blog</a></li>
          
            <li><a href="https://montekki.github.io/tags">Tags</a></li>
          
            <li><a href="https://montekki.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<time datetime="2022-12-06">December  6, 2022</time>
  	</div>
  	<h1 class="post-title">The GKR Protocol</h1>
  	<div class="post-line"></div>
  	<p>It has been a long time since the last post but it is
finally time to play around with the last major protocol from
Chapter 4 in The Book: the GKR protocol. It will involve running
a protocol inside another protocol, let's go.</p>
<span id="continue-reading"></span>
<p>The GKR protocol is an interactive protocol for Arithmetic Circuit
evaluation. The Arithmetic Circuit would be a circuit that has
an input layer, an output layer and layers of gates in between.
Gates may be addition or multiplication ones and each one of them
takes exactly two inputs from the previous layer and outputs exactly
one value to the next layer.</p>
<p>The prover $P$ starts the protocol with a claim about the output
of the circuit given some input. $V$ wants to verify this claim
without performing the actual circuit evaluation.</p>
<p>One other assumption is that the number of gates at each layer is a
power of $2$.</p>
<h2 id="implementing-the-primitive-for-the-arithmetic-circuit">Implementing the primitive for the Arithmetic Circuit</h2>
<p>The concept of an Arithmetic Circuit is not a very complicated one
it would make sense to start the implementation with it.</p>
<p>So the type of the gates would be straightforward:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub enum </span><span>GateType {
</span><span>    Add,
</span><span>    Mul,
</span><span>}
</span></code></pre>
<p>Each gate needs to specify its type and what are the inputs from the
previous layer (in our case just two indices into a slice):</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>Gate {
</span><span>    </span><span style="color:#d73737;">ttype</span><span>: GateType,
</span><span>    </span><span style="color:#d73737;">inputs</span><span>: [</span><span style="color:#b854d4;">usize</span><span>; 2],
</span><span>}
</span></code></pre>
<p>And a layer of a circuit would just be a row of gates:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>CircuitLayer {
</span><span>    </span><span style="color:#d73737;">layer</span><span>: Vec&lt;Gate&gt;,
</span><span>}
</span></code></pre>
<p>Great, now we can describe the circuit which would hold the info
about the layers and a number of inputs.</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>Circuit {
</span><span>    </span><span style="color:#d73737;">layers</span><span>: Vec&lt;CircuitLayer&gt;,
</span><span>    </span><span style="color:#d73737;">num_inputs</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>}
</span></code></pre>
<p>So what info about evaluation this circuit would we need for the protocol?
Not only the circuit outputs will be needed but all the values of all
gates outputs at each layer. So the evaluation type may be described
as such:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>CircuitEvaluation&lt;F&gt; {
</span><span>    </span><span style="color:#999580;">/// Evaluations on per-layer basis.
</span><span>    </span><span style="color:#b854d4;">pub </span><span style="color:#d73737;">layers</span><span>: Vec&lt;Vec&lt;F&gt;&gt;,
</span><span>}
</span></code></pre>
<p>The implementation of circuit evaluation is trivial:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl </span><span>Circuit {
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">evaluate</span><span>&lt;F&gt;(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">input</span><span>: &amp;[F]) -&gt; CircuitEvaluation&lt;F&gt;
</span><span>    </span><span style="color:#b854d4;">where
</span><span>        F: Add&lt;Output = F&gt; + Mul&lt;Output = F&gt; + Copy,
</span><span>    {
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> layers = vec![];
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> current_input = input;
</span><span>
</span><span>        layers.</span><span style="color:#1fad83;">push</span><span>(input.</span><span style="color:#1fad83;">to_vec</span><span>());
</span><span>
</span><span>        </span><span style="color:#b854d4;">for</span><span> layer in </span><span style="color:#d73737;">self</span><span>.layers.</span><span style="color:#1fad83;">iter</span><span>().</span><span style="color:#1fad83;">rev</span><span>() {
</span><span>            </span><span style="color:#b854d4;">let</span><span> temp_layer: Vec&lt;_&gt; = layer
</span><span>                .layer
</span><span>                .</span><span style="color:#1fad83;">iter</span><span>()
</span><span>                .</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">e</span><span>| </span><span style="color:#b854d4;">match</span><span> e.ttype {
</span><span>                    GateType::Add =&gt; current_input[e.inputs[</span><span style="color:#b65611;">0</span><span>]] + current_input[e.inputs[</span><span style="color:#b65611;">1</span><span>]],
</span><span>                    GateType::Mul =&gt; current_input[e.inputs[</span><span style="color:#b65611;">0</span><span>]] * current_input[e.inputs[</span><span style="color:#b65611;">1</span><span>]],
</span><span>                })
</span><span>                .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>            layers.</span><span style="color:#1fad83;">push</span><span>(temp_layer);
</span><span>            current_input = &amp;layers[layers.</span><span style="color:#1fad83;">len</span><span>() - </span><span style="color:#b65611;">1</span><span>];
</span><span>        }
</span><span>
</span><span>        layers.</span><span style="color:#1fad83;">reverse</span><span>();
</span><span>        CircuitEvaluation { layers }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Since the circuit itself only describes the gates structure and is
agnostic towards the types of the values it can evaluate it makes
sense implementing the evaluation being generic over any type that
can be <code>Add</code>ed and <code>Mul</code>tiplied.</p>
<p>The other two functions needed for the protocol are
$\text{add}_i$ and $\text{mul}_i$ that constitute the wiring predicate
of the layer $i$. It would be best to look up the definitions of
these functions in The Book, but the intuition for them is this:</p>
<p>Each of these functions takes as input three labels:</p>
<ol>
<li>One label of the gate in the layer $i$.</li>
<li>Two labels of the gates in the layer $i+1$.</li>
</ol>
<p>Each of these functions outputs 1 in case the said two gates from $i+1$
are the inputs of the gate at level $i$ <em>and</em> if that is an addition
or multiplication gate respectively. The protocol is going to use
$\widetilde{add}_i$ and $\widetilde{mul}_i$ multilinear extensions
of these functions with the first $n$-something variables fixed.</p>
<p>The types of methods for computing these multilinear extensions would
look like this, I am omitting the code here for ergonomics:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl </span><span>Circuit {
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">add_i_ext</span><span>&lt;F: Field&gt;(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">r_i</span><span>: &amp;[F], </span><span style="color:#d73737;">i</span><span>: </span><span style="color:#b854d4;">usize</span><span>) -&gt;
</span><span>        DenseMultilinearExtension&lt;F&gt; {
</span><span>        </span><span style="color:#999580;">// ...
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">mul_i_ext</span><span>&lt;F: Field&gt;(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">r_i</span><span>: &amp;[F], </span><span style="color:#d73737;">i</span><span>: </span><span style="color:#b854d4;">usize</span><span>) -&gt;
</span><span>        DenseMultilinearExtension&lt;F&gt; {
</span><span>        </span><span style="color:#999580;">// ...
</span><span>    }
</span></code></pre>
<p>Other than that the <code>Circuit</code> would have some getter methods but that
is too trivial to be included here.</p>
<p>The implementations of the above types may be found in
<a href="https://github.com/montekki/thaler-study/blob/9cdc7c37d866dfae0e4bec1d485159d3433aca6b/gkr-protocol/src/circuit.rs"><code>circuit.rs</code></a></p>
<h2 id="building-the-sum-check-polynomial">Building the Sum-Check polynomial</h2>
<p>Another function that is used in the protocol is
$W_i : \lbrace 0, 1 \rbrace \rightarrow \mathbb{F}$ that
takes a binary gate label and outputs the gate's value at layer $i$.
Again, in the protocol the MLE $\tilde{W}_i$ of $W_i$ is going to
be used.</p>
<p>At each round of the GKR protocol an instance of Sum-Check protocol
is run for the following polynomial:</p>
<p>$$
f^{(i)}_{r_i}(b, c) := \widetilde{add}_i(r_i, b, c)
(\tilde{W}_{i+1}(b) + \tilde{W}_{i+1}(c)) +
\widetilde{mul}_i(r_i, b, c)
(\tilde{W}_{i+1}(b) \cdot \tilde{W}_{i+1}(c))
$$</p>
<p>For some fixed set of first variables $r_i$.</p>
<p>The definition of the above polynomial would be something like this:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>W&lt;F: Field&gt; {
</span><span>    </span><span style="color:#d73737;">add_i</span><span>: DenseMultilinearExtension&lt;F&gt;,
</span><span>    </span><span style="color:#d73737;">mul_i</span><span>: DenseMultilinearExtension&lt;F&gt;,
</span><span>    </span><span style="color:#d73737;">w_b</span><span>: DenseMultilinearExtension&lt;F&gt;,
</span><span>    </span><span style="color:#d73737;">w_c</span><span>: DenseMultilinearExtension&lt;F&gt;,
</span><span>}
</span></code></pre>
<p>The implementation of necessary trait <code>SumCheckPolynomial</code> for
this poly is purely mechanical and the logic behind it can be
found in the previous posts. The source code itself can be found
at
<a href="https://github.com/montekki/thaler-study/blob/9cdc7c37d866dfae0e4bec1d485159d3433aca6b/gkr-protocol/src/round_polynomial.rs"><code>round_polynomial.rs</code></a></p>
<h2 id="restricting-a-polynomial-to-a-line">Restricting a polynomial to a line</h2>
<p>One of more interesting and non-trivial building blocks of this
protocol is the reduction of two evaluations of $\tilde{W}_i$ at
two points $b$ and $c$ to a single evaluation at some point.
This trick was described earlier in the book at section 4.5.2 and
was used to shave off a constant from the verifier running time.</p>
<p>Here it is used since the verifier does not know $\tilde{W}_i$.</p>
<p>In essence suppose we have two points $b, c \in \mathbb{F}^{\log n}$.
We want to create such a line
$l : \mathbb{F} \rightarrow \mathbb{F}^{\log n}$
that $l(0) = b$ and $l(1) = c$. Then a multivariate polynomial, say,
$\tilde{W}_i(b)$ may be restricted to line $l$.</p>
<p>In general case $l$ can be written as $n$ linear equations:</p>
<p>$$
l(x) = (k_1 x +l_1, k_2 x + l_2,\cdots,k_n x + l_n)
$$</p>
<p>Lets mark the $i$-th component on the right side</p>
<p>$$
l_i(x) = (k_i x + l_i)
$$</p>
<p>Also it is given that $l_i(0) = b_i$ and $l_i(1) = c_i$
which gives us a system of linear equations:</p>
<p>$$
\begin{cases}
k_i \cdot 0 + l_i = b_i \\
k_i \cdot 1 + l_i = c_i
\end{cases}
$$</p>
<p>Simplifying first then substituting result into second:</p>
<p>$$
\begin{cases}
l_i = b_i \\
k_i = c_i - b_i
\end{cases}
$$</p>
<p>And as such $l_i(x) = (c_i - b_i)\cdot x + b_i$.</p>
<p>For example</p>
<p>$b = (2, 4), c = (3, 2)$</p>
<p>$l(t) = ((3-2)\cdot t + 2, (2-4)\cdot t + 4)$</p>
<p>$l(t) = (t + 2, 4 -2\cdot t)$. $\square$</p>
<p>And then for polynomial $\tilde{W}(x_1,x_2) = 3x_1x_2 + 2x_2$ the
restriction of $\tilde{W}$ to $l$ is
$3(t + 2)(4 - 2t) + 2(4 - 2t) = -6t^2 - 4t + 32$.</p>
<p>Now for the first step of creating an above line $l$ the
implementation is as follows:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">line</span><span>&lt;F: Field&gt;(</span><span style="color:#d73737;">b</span><span>: &amp;[F], </span><span style="color:#d73737;">c</span><span>: &amp;[F]) -&gt; Vec&lt;univariate::SparsePolynomial&lt;F&gt;&gt; {
</span><span>    iter::zip(b, c)
</span><span>        .</span><span style="color:#1fad83;">map</span><span>(|(</span><span style="color:#d73737;">b</span><span>, </span><span style="color:#d73737;">c</span><span>)| {
</span><span>            univariate::SparsePolynomial::from_coefficients_slice(&amp;[(</span><span style="color:#b65611;">0</span><span>, *b), (</span><span style="color:#b65611;">1</span><span>, *c - b)])
</span><span>        })
</span><span>        .</span><span style="color:#1fad83;">collect</span><span>()
</span><span>}
</span></code></pre>
<p>The second part with the restriction of the polynomial $\tilde{W}$ to
this line is quite harder since it involves multiplying univariate
polynomials with each other and the logistics of this in <code>arkworks</code>
is not ideal so the code has to go back and forth between different
types of univariate polynomials:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">restrict_poly</span><span>&lt;F: Field, M: MultilinearExtension&lt;F&gt;&gt;(
</span><span>    </span><span style="color:#d73737;">b</span><span>: &amp;[F],
</span><span>    </span><span style="color:#d73737;">c</span><span>: &amp;[F],
</span><span>    </span><span style="color:#d73737;">mle</span><span>: &amp;M,
</span><span>) -&gt; univariate::SparsePolynomial&lt;F&gt; {
</span><span>    </span><span style="color:#b854d4;">let</span><span> k: Vec&lt;_&gt; = iter::zip(b, c).</span><span style="color:#1fad83;">map</span><span>(|(</span><span style="color:#d73737;">b</span><span>, </span><span style="color:#d73737;">c</span><span>)| *c - b).</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>    </span><span style="color:#b854d4;">let</span><span> evaluations = mle.</span><span style="color:#1fad83;">to_evaluations</span><span>();
</span><span>    </span><span style="color:#b854d4;">let</span><span> num_vars = mle.</span><span style="color:#1fad83;">num_vars</span><span>();
</span><span>
</span><span>    </span><span style="color:#b854d4;">let mut</span><span> res = univariate::SparsePolynomial::zero();
</span><span>
</span><span>    </span><span style="color:#b854d4;">for </span><span>(i, evaluation) in evaluations.</span><span style="color:#1fad83;">iter</span><span>().</span><span style="color:#1fad83;">enumerate</span><span>() {
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> p = univariate::SparsePolynomial::from_coefficients_vec(vec![(</span><span style="color:#b65611;">0</span><span>, *evaluation)]);
</span><span>        </span><span style="color:#b854d4;">for</span><span> bit in </span><span style="color:#b65611;">0</span><span>..num_vars {
</span><span>            </span><span style="color:#b854d4;">let mut</span><span> b =
</span><span>                univariate::SparsePolynomial::from_coefficients_vec(vec![(</span><span style="color:#b65611;">0</span><span>, b[bit]), (</span><span style="color:#b65611;">1</span><span>, k[bit])]);
</span><span>
</span><span>            </span><span style="color:#b854d4;">if</span><span> i &amp; (</span><span style="color:#b65611;">1 </span><span>&lt;&lt; bit) == </span><span style="color:#b65611;">0 </span><span>{
</span><span>                b = (&amp;univariate::DensePolynomial::from_coefficients_vec(vec![F::one()]) - &amp;b)
</span><span>                    .</span><span style="color:#1fad83;">into</span><span>();
</span><span>            }
</span><span>
</span><span>            p = p.</span><span style="color:#1fad83;">mul</span><span>(&amp;b);
</span><span>        }
</span><span>
</span><span>        res += &amp;p;
</span><span>    }
</span><span>
</span><span>    res
</span><span>}
</span></code></pre>
<p>The idea behind this code is that we first need to go from
MLE in evaluation form to a polynomial in coefficients form via
Lagrange interpolation. Then the resulting polynomial must
be restricted to line $l$. However, I've found that the easiest
way to do the above two steps with <code>arkworks</code> is to do them at the same
time and sort of interpolate directly into the restricted univariate
polynomial.</p>
<h2 id="the-rest-of-the-protocol">The rest of the protocol</h2>
<p>The remainder of the protocol implementation is purely mechanical
and involves wiring together the Sum-Check protocols that are run
at each layer. The mechanical pages are no fun to describe plus I
am not quite happy how they turned out. Maybe I will revisit the
messaging implementation in the future and make it the topic for
a followup post. The code of the protocol can be found in
<a href="https://github.com/montekki/thaler-study/blob/9cdc7c37d866dfae0e4bec1d485159d3433aca6b/gkr-protocol/src/lib.rs"><code>lib.rs</code></a>. Thanks for reading and stay tuned!</p>
<hr />
<p>Reference list.</p>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/2008-DelegatingComputation.pdf">Original paper by Shafi Goldwasser, Yael Kalai and Guy Rothblum</a></p>
<p><a href="https://www.youtube.com/watch?v=x8pUxFptfb0">YouTube: GKR based Zero-Knowledge Proofs - Yael Kalai, Microsoft Research</a></p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; <time datetime="2025-08-13T09:59:53.945483108+00:00">2022-2025</time> Fedor Sakharov. </span>
  </footer>
  
</body>
</html>
