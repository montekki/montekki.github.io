<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Generalizing Sum Check protocol and counting the triangles</title>



<meta property="og:title" content="Generalizing Sum Check protocol and counting the triangles">



<meta name="author" content="Fedor Sakharov">


<meta property="og:locale" content="en_US">




<link rel="canonical" href="https://montekki.github.io/thaler-ch4-2/">
<meta property="og:url" content="https://montekki.github.io/thaler-ch4-2/">





  <meta property="og:image" content="https://montekki.github.io/assets/favicon.jpg">
  
  



  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2022-08-22T00:00:00+00:00">







  <meta name="twitter:card" content="summary_large_image"">
  <meta property="twitter:image" content="https://montekki.github.io/assets/favicon.jpg">



  <meta property="twitter:title" content="Generalizing Sum Check protocol and counting the triangles">



  <meta name="twitter:site" content="@m0nt3kk1">
  






<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"Fedor Sakharov"
  },
  "description": "",
  "url": "https://montekki.github.io/thaler-ch4-2/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Generalizing Sum Check protocol and counting the triangles"
  
    
    
      "datePublished":"2022-08-22T00:00:00+00:00",
    
    ,
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://montekki.github.io/thaler-ch4-2/"
    }
  
}
</script>

  <link rel="stylesheet" href="https://montekki.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://montekki.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://montekki.github.io/assets/favicon-16x16.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://montekki.github.io/atom.xml" title="" />
  

  

  
  

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
                                                                                                                                                                                                            <script>


        document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
    </script>


</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://montekki.github.io">
        <h2 class="nav-title"></h2>
      </a>
      <ul>
        
          
            <li><a href="https://montekki.github.io">Blog</a></li>
          
            <li><a href="https://montekki.github.io/tags">Tags</a></li>
          
            <li><a href="https://montekki.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<time datetime="2022-08-22">August 22, 2022</time>
  	</div>
  	<h1 class="post-title">Generalizing Sum Check protocol and counting the triangles</h1>
  	<div class="post-line"></div>
  	<p>Welcome back. In the <a href="https://montekki.github.io/thaler-ch4-1/">previous post</a> we have
taken a first look at the Sum Check protocol from The Book and implemented
it for the case of <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/polynomial/multivariate/struct.SparsePolynomial.html"><code>multivariate::SparsePolynomial</code></a>.
In this post I am going to attempt to generalize the protocol to
any polynomial and apply it to the Counting Triangles in Graphs problem.</p>
<span id="continue-reading"></span>
<p>In the previous post an implementation of the Sum Check protocol for the
special case of <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/polynomial/multivariate/struct.SparsePolynomial.html"><code>multivariate::SparsePolynomial</code></a> was described. But if you
have been reading The Book or following the
<a href="https://www.youtube.com/watch?v=4_ALgSnUM20">online book reading group</a>
you may already know that for the most interesting cases Sum Check protocol
has to be applied some simple polynomial that would involve multiplying or
summing multilinear extensions.</p>
<p>So for the triangle counting problem the polynomial $g$ would take the form</p>
<p>$$
g(X, Y, Z) = \widetilde{f_A}(X, Y) \cdot \widetilde{f_A}(Y, Z) \cdot \widetilde{f_A}(X, Z)
$$</p>
<p>or in the case of GKR protocol $g$ would be</p>
<p>$$
f_{r_i}^{(i)}(b, c) = \widetilde{add}_i(r_i, b, c)
(\widetilde{W}_{i+1}(b) + \widetilde{W}_{i+1}(c)) +
\widetilde{mult}_i(r_i, b, c)
(\widetilde{W}_{i+1}(b) \widetilde{W}_{i+1}(c))
$$</p>
<p>As you may see these polynomials are multiplications and additions of
multilinear extensions of quite low degrees.</p>
<p>It would be nice to somehow generalize the sum-check protocol to be
able to deal with any polynomial type and the above polynomials in particular.
Thankfully Rust has all the tools needed to perform this kind of abstraction.</p>
<h2 id="abstracting-sum-check-protocol-over-the-type-of-polynomial">Abstracting Sum Check protocol over the type of polynomial</h2>
<p>What actions does the Sum Check protocol perform with the given polynomial
anyway?</p>
<ol>
<li>
<p>First the protocol needs to know the number of variables in the polynomial.</p>
</li>
<li>
<p>Then obviously the Verifier of the protocol has
to be able to evaluate the polynomial at a random point at the end of
the last round.</p>
</li>
<li>
<p>Recall, that on the $j$-th round Prover fixes all but one variables
in $g$ turning it into a univariate polynomial $g_j(X_j)$ being
$$
\sum_{(x_{j+1},...,x_{\nu}) \in \lbrace 0,1 \rbrace^{\nu - j}}
g(r_i,...,r_{j-1},X_j,x_{j+1},...,x_{\nu})
$$
This suggests that the polynomial has to have a way to fix all but one variables.</p>
</li>
<li>
<p>And finally there has to be a way to get the evaluations of this
polynomial over the boolean hypercube. Summing these evaluations gives
the value $c_1$ that Prover claims to be the true answer at the beginning
of the first round.</p>
</li>
</ol>
<p>These can be described as a trait in Rust like this:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub trait </span><span>SumCheckPolynomial&lt;F: Field&gt; {
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">evaluate</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">point</span><span>: &amp;[F]) -&gt; Option&lt;F&gt;;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">to_univariate_at_point</span><span>(
</span><span>        &amp;</span><span style="color:#d73737;">self</span><span>,
</span><span>        </span><span style="color:#d73737;">at</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>        </span><span style="color:#d73737;">point</span><span>: &amp;[F],
</span><span>    ) -&gt; Option&lt;univariate::SparsePolynomial&lt;F&gt;&gt;;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">num_vars</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>) -&gt; </span><span style="color:#b854d4;">usize</span><span>;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">to_evaluations</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>) -&gt; Vec&lt;F&gt;;
</span><span>}
</span></code></pre>
<p>For now some methods in this trait return <code>Option</code>-al values in case
some errors happen for instance, if the dimension of the point does
not match the dimension of the polynomial.</p>
<p>Now, to reflect this change in the existing code of the Sum Check protocol
that was implemented in the previous post all we have to do is implement
the trait above for <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/polynomial/multivariate/struct.SparsePolynomial.html"><code>multivariate::SparsePolynomial</code></a>:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: Field&gt; SumCheckPolynomial&lt;F&gt; </span><span style="color:#b854d4;">for </span><span>multivariate::SparsePolynomial&lt;F, SparseTerm&gt; {
</span><span>    ...
</span><span>}
</span></code></pre>
<p>and change <code>Prover</code> and <code>Verifier</code> to be generic over this new trait:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>Verifier&lt;F: Field, P: SumCheckPolynomial&lt;F&gt;&gt; {
</span><span>    ...
</span><span>}
</span><span>
</span><span>
</span><span style="color:#b854d4;">pub struct </span><span>Prover&lt;F: Field, P: SumCheckPolynomial&lt;F&gt;&gt; {
</span><span>    ...
</span><span>}
</span></code></pre>
<p>The rest of the changes are purely mechanical and can be found in
<a href="https://github.com/montekki/thaler-study/commit/d32e6fc445409e89ce34675d26af0b0f3b8ea369">this commit</a>.</p>
<h2 id="sum-check-protocol-to-count-triangles">Sum Check Protocol to Count Triangles</h2>
<p>For the triangle counting problem we are going to be dealing with the
polynomial already mentioned above:</p>
<p>$$
g(X, Y, Z) = \widetilde{f_A}(X, Y) \cdot \widetilde{f_A}(Y, Z) \cdot \widetilde{f_A}(X, Z)
$$</p>
<p>What is this polynomial? Well, suppose we are given a graph G,
E - a set of edges in G and $A$ is the adjacency matrix of
the graph $G$, i.e. $A_{i,j} = 1 \Leftrightarrow (i, j) \in F$.
The matrix $A$ is used to count the number of triangles in this graph.</p>
<p>To do that matrix $A$ is viewed not as a matrix but rather as a
function $f_A$ mapping
$\lbrace 0, 1 \rbrace^{\log n} \times \lbrace 0, 1 \rbrace^{\log n} \rightarrow \lbrace 0, 1 \rbrace$ where indices $i,j$ are viewed
as arrays of bits of $\log n$. Then the formula for counting the number
of triangles would look like this:</p>
<p>$$
\Delta = \frac{1}{6} \sum_{ x,y,x \in \lbrace 0, 1 \rbrace ^{\log n}}
f_A(x,y) \cdot f_A(y,z) \cdot f_A(x,z)
$$</p>
<p>To define the polynomial that can
be used in the Sum Check protocol the multilinear extension
$\widetilde{f_A}$ of $f_A$ is used and so we arrive at the above
polynomial $g(X, Y, Z)$.</p>
<pre style="background-color:#fefbec;color:#6e6b5e;"><code><span>For more detailed description of going from the $A$ to the polynomial
</span><span>you should check out The Book, we are now going to get to implementing
</span><span>this in Rust.
</span></code></pre>
<p>Since we are going to deal with the polynomial that is the multiplication
of three evaluations of the same multilinear extension function over a
different set of variables we can define our polynomial as follows:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>G&lt;F: Field&gt; {
</span><span>    </span><span style="color:#d73737;">f_a</span><span>: DenseMultilinearExtension&lt;F&gt;,
</span><span>}
</span></code></pre>
<p>Here we use a <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/struct.DenseMultilinearExtension.html"><code>DenseMultilinearExtension</code></a>
from the <code>ark_poly</code> crate to implement the $\widetilde{f_A}$.</p>
<p>First lets implement the constructor that would allow
to go from the adjacency matrix $A$ to our multilinear extension.</p>
<p>Being generic over any iterable structure of <code>bool</code> values:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: Field&gt; G&lt;F&gt; {
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">new_adj_matrix</span><span>&lt;M&gt;(</span><span style="color:#d73737;">num_vars</span><span>: </span><span style="color:#b854d4;">usize</span><span>, </span><span style="color:#d73737;">matrix</span><span>: M) -&gt; </span><span style="color:#b854d4;">Self
</span><span>    </span><span style="color:#b854d4;">where
</span><span>        M: IntoIterator&lt;Item = </span><span style="color:#b854d4;">bool</span><span>&gt;,
</span><span>    {
</span><span>        </span><span style="color:#b854d4;">let</span><span> g = DenseMultilinearExtension::from_evaluations_vec(
</span><span>            num_vars,
</span><span>            matrix
</span><span>                .</span><span style="color:#1fad83;">into_iter</span><span>()
</span><span>                .</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">b</span><span>| </span><span style="color:#b854d4;">if</span><span> b { F::one() } </span><span style="color:#b854d4;">else </span><span>{ F::zero() })
</span><span>                .</span><span style="color:#1fad83;">collect</span><span>(),
</span><span>        );
</span><span>
</span><span>        </span><span style="color:#b854d4;">Self </span><span>{ f_a: g }
</span><span>    }
</span><span>}
</span></code></pre>
<hr />
<p><strong>NOTE</strong>
<code>arkworks</code> uses assertions within implementations of methods,
the <code>from_evaluations_vec</code> constructor will panic if the dimensions
of input parameters do not match.</p>
<hr />
<p>Next, to use this polynomial with the new generic version of the Sum Check
protocol defined above the <code>SumCheckPolynomial</code> trait for it.
As I am going to implement it as close to The Book as possible it is going
to get quite ugly.</p>
<p>First, the <code>evaluate</code> method. Recall, that the polynomial has the input
of the form $(x_1,\dots,x_n,y_1,\dots,y_n,z_1,\dots,z_n)$ and our
multilinear extension <code>f_a</code> has to be evaluated three times over
respective parts of this input:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: FftField&gt; SumCheckPolynomial&lt;F&gt; </span><span style="color:#b854d4;">for </span><span>G&lt;F&gt; {
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">evaluate</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">point</span><span>: &amp;[F]) -&gt; Option&lt;F&gt; {
</span><span>        assert!(point.</span><span style="color:#1fad83;">len</span><span>() == (</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>) * </span><span style="color:#b65611;">3</span><span>);
</span><span>
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> x_z = point[..</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>].</span><span style="color:#1fad83;">to_owned</span><span>();
</span><span>        x_z.</span><span style="color:#1fad83;">extend_from_slice</span><span>(&amp;point[</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>()..]);
</span><span>        </span><span style="color:#999580;">// X, Y
</span><span>        Some(
</span><span>            </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">evaluate</span><span>(&amp;point[..</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>()])? *
</span><span>            </span><span style="color:#999580;">// Y, Z
</span><span>            </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">evaluate</span><span>(&amp;point[</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2 </span><span>.. ])?
</span><span>            * </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">evaluate</span><span>(&amp;x_z)?,
</span><span>        )
</span><span>    }
</span></code></pre>
<p>Here the cases of $(x, y)$ and $(y,z)$ are trivial since they can
be simply taken as subslices of the input, however the $(x, z)$ case
involves constructing the new vector since we are limited by how the
contiguous memory works and I haven't found a better in-place solution yet.
If <code>DenseMultilinearExtension::evaluate</code> API would be able to take
something iterable instead of a slice, one could just chain to
iterators of subslices.</p>
<p>Next, one trivial method to compute the number of variables
based on the number of variables of the underlying <code>DenseMultilinearExtension</code>:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">num_vars</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>) -&gt; </span><span style="color:#b854d4;">usize </span><span>{
</span><span>        (</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>) * </span><span style="color:#b65611;">3
</span><span>    }
</span></code></pre>
<p>The <code>to_evaluations</code> method is going to be a bit more tricky. What we have at
hand is the <code>f_a</code> multilinear extension. The trait <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/evaluations/multivariate/multilinear/trait.MultilinearExtension.html"><code>MultilinearExtension</code></a> provides us with a <code>to_evaluations</code> method that "returns a list of evaluations
over the domain, which is the boolean hypercube". But the domain of $f_A$ is $(X, Y)$ and
in our case the domain of $g$ is $(X, Y, Z)$. It is clear that at each point in its
domain $g$ is a multiplication of exactly three values from the vector of evaluations
of $f_A$ over $f_A$'s domain, in other words these said three values are just values
from <code>f_a.to_evaluations()</code> vector. But how do we compute the needed values to correctly
index into this vector? Some good old bitmasking and bit shifting of course:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">to_evaluations</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>) -&gt; Vec&lt;F&gt; {
</span><span>        </span><span style="color:#b854d4;">let</span><span> x_size = </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>;
</span><span>        </span><span style="color:#b854d4;">let</span><span> bit_mask_most_significant = ((</span><span style="color:#b854d4;">usize</span><span>::</span><span style="color:#b65611;">MAX </span><span>&lt;&lt; x_size) ^ </span><span style="color:#b854d4;">usize</span><span>::</span><span style="color:#b65611;">MAX</span><span>) &lt;&lt; x_size;
</span><span>
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> res = vec![F::zero(); </span><span style="color:#b65611;">2</span><span style="color:#b854d4;">usize</span><span>.</span><span style="color:#1fad83;">pow</span><span>(</span><span style="color:#d73737;">self</span><span>.</span><span style="color:#1fad83;">num_vars</span><span>() as </span><span style="color:#b854d4;">u32</span><span>)];
</span><span>        </span><span style="color:#b854d4;">let</span><span> evaluations = </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">to_evaluations</span><span>();
</span><span>
</span><span>        </span><span style="color:#b854d4;">for </span><span>(x_y, evaluation) in evaluations.</span><span style="color:#1fad83;">iter</span><span>().</span><span style="color:#1fad83;">enumerate</span><span>() {
</span><span>            </span><span style="color:#b854d4;">for</span><span> z in </span><span style="color:#b65611;">0</span><span>..</span><span style="color:#b65611;">2</span><span style="color:#b854d4;">usize</span><span>.</span><span style="color:#1fad83;">pow</span><span>(x_size as </span><span style="color:#b854d4;">u32</span><span>) {
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_x_y = evaluation;
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_y_z_idx = ((x_y &lt;&lt; x_size) &amp; bit_mask_most_significant) | z;
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_y_z = evaluations[f_y_z_idx];
</span><span>
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_x_z_idx = (x_y &amp; bit_mask_most_significant) | z;
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_x_z = evaluations[f_x_z_idx];
</span><span>
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_x_y_z = (*f_x_y * f_y_z) * f_x_z;
</span><span>
</span><span>                res[(x_y &lt;&lt; x_size) | z] = f_x_y_z;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        res
</span><span>    }
</span></code></pre>
<p>And now the last one: going to a univariate polynomial by fixing
all variables but one.</p>
<p>Let's think about it:</p>
<p>Suppose we are given a point $(x_1,\dots,x_n,y_1,\dots,y_n,z_1,\dots,z_n)$
and the index $i$ of the variable that has to remain un-fixed so to speak.</p>
<p>Index $i$ lands into either $X$, $Y$ or $Z$:</p>
<ul>
<li>
<p>$(x_1,\dots,x_{i-1},x_i,x_{i+1},\dots,x_n,y_1,\dots,y_n,z_1,\dots,z_n)$</p>
</li>
<li>
<p>$(x_1,\dots,x_n,y_1,\dots,y_{i-1-n},y_{i-n},y_{i+1-n},\dots,y_n,z_1,\dots,z_n)$</p>
</li>
<li>
<p>$(x_1,\dots,x_n,y_1,\dots,y_n,z_1,\dots,z_{i-1-2n},z_{i-2n},z_{i+1-2n},\dots, z_n)$</p>
</li>
</ul>
<p>And as such it would affect two out of three factors $\widetilde{f_A}$
in our polynomial. The third factor can be just evaluated at a constant
point since it is not affected by this change.</p>
<h2 id="going-to-a-univariate-polynomial">Going to a univariate polynomial</h2>
<p>The rust code that handles the case when $i$ lands in $X$:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">to_univariate_at_point</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">at</span><span>: </span><span style="color:#b854d4;">usize</span><span>, </span><span style="color:#d73737;">point</span><span>: &amp;[F]) -&gt; Option&lt;SparsePolynomial&lt;F&gt;&gt; {
</span><span>        </span><span style="color:#b854d4;">let</span><span> x_y = &amp;point[..</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>()];
</span><span>        </span><span style="color:#b854d4;">let</span><span> y_z = &amp;point[</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>..];
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> x_z = point[..</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>].</span><span style="color:#1fad83;">to_owned</span><span>();
</span><span>        x_z.</span><span style="color:#1fad83;">extend_from_slice</span><span>(&amp;point[</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>()..]);
</span><span>
</span><span>        </span><span style="color:#b854d4;">match</span><span> at / (</span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() / </span><span style="color:#b65611;">2</span><span>) {
</span><span>            </span><span style="color:#b65611;">0 </span><span>=&gt; {
</span><span>                </span><span style="color:#b854d4;">let</span><span> f_y_z = </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">evaluate</span><span>(y_z).</span><span style="color:#1fad83;">unwrap</span><span>();
</span><span>
</span><span>                </span><span style="color:#b854d4;">let</span><span> a = </span><span style="color:#d73737;">self</span><span>.</span><span style="color:#1fad83;">g_to_univariate_at</span><span>(at, x_y);
</span><span>                </span><span style="color:#b854d4;">let</span><span> b = </span><span style="color:#d73737;">self</span><span>.</span><span style="color:#1fad83;">g_to_univariate_at</span><span>(at, &amp;x_z);
</span><span>                Some((&amp;(&amp;a * &amp;b) * f_y_z).</span><span style="color:#1fad83;">into</span><span>())
</span><span>            }
</span><span>        </span><span style="color:#999580;">/* Cases for 1 and 2 are similar */
</span></code></pre>
<p>Again, we have to go use the same trick we used above to
use a new vector to construct a value for $(X, Z)$. Another thing
is that the helper <code>g_to_univariate_at</code> helper is used here
that allows to fix all but one variables in <code>f_a</code> and turn it into
a univariate polynomial.</p>
<p>How could this helper be implemented?
Let's look at all the building blocks that can go into this implementation:</p>
<p><a href="https://docs.rs/ark-poly/0.3.0/ark_poly/struct.DenseMultilinearExtension.html"><code>DenseMultilinearExtension</code></a> implements the <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/evaluations/multivariate/multilinear/trait.MultilinearExtension.html"><code>MultilinearExtension</code></a>
trait that among other things allows to fix a number of variables:</p>
<blockquote>
<p>Reduce the number of variables of self by fixing
the <code>partial_point.len()</code> variables at <code>partial_point</code>.</p>
</blockquote>
<p>So we can go to the fewer variable polynomial by fixing the <em>first</em> $i$
variables.</p>
<p>It also implements a method that allows us to swapping variables
(see the <code>replace</code> method).</p>
<p>How can we use these two? In a very unelegant way:</p>
<p>Suppose we have a point where we want to go to univariate poly at $i$:</p>
<p>$$
(x_1,\dots,x_{i-1},x_i,x_{i+1},\dots,x_n,y_1,\dots,y_n)
$$</p>
<ol>
<li>
<p>Use <code>fix_variables</code> at point $(x_1,\dots,x_{i-1})$, now we have:
$$
(x_i,x_{i+1},\dots,x_n,y_1,\dots,y_n)
$$</p>
</li>
<li>
<p>Use <code>replace</code> method to swap $x_i$ and $y_n$, to arrive at:
$$
(y_n,x_{i+1},\dots,x_n,y_1,\dots,y_{n-1},x_i)
$$</p>
</li>
<li>
<p>Again, use <code>fix_variables</code> at point $(y_n)$:
$$
(x_{i+1},\dots,x_n,y_1,\dots,y_{n-1},x_i)
$$</p>
</li>
<li>
<p>And finally use <code>fix_variables</code> again, this time at point $(x_{i+1},\dots,y_{n-1})$:
$$
(x_i)
$$</p>
</li>
</ol>
<p>The last two steps could be squashed into a single one if we could
swap to points in a vector, but we are using a slice instead of a vector.</p>
<p>At the end of these series of steps we will end up with a
univariate <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/struct.DenseMultilinearExtension.html"><code>DenseMultilinearExtension</code></a> over variable $i$.</p>
<p>Now the only thing separating us from the finalizing implementation
of the needed trait is turning this univariate extension into a
univariate <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/polynomial/univariate/struct.SparsePolynomial.html"><code>univariate::SparsePolynomial</code></a>, since, you know, we are using Rust
to typesafely guarantee that the polynomial is actually univariate.</p>
<p>What we know is that $g$ is a polynomial with degree at most $2$ in
each variable so this univariate extension is an extension polynomial
of degree of at most $2$. Quadratic polynomials can be described with
at most $3$ coefficients. So we actually can interpolate our quadratic
<code>SparsePolynomial</code> from evaluations of the extension. Luckily, <code>ark-poly</code>
gives us exactly the machinery to do this with the types
<a href="https://docs.rs/ark-poly/0.3.0/ark_poly/domain/general/enum.GeneralEvaluationDomain.html"><code>GeneralEvaluationDomain</code></a> and <a href="https://docs.rs/ark-poly/0.3.0/ark_poly/evaluations/univariate/struct.Evaluations.html"><code>Evaluations</code></a>
that stores a univariate polynomial in the evaluations form.
Then we just call the <code>interpolate</code> method on the latter to get
to the needed polynomial.</p>
<p>Here is the code for all the steps above that implements the said helper:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: FftField&gt; G&lt;F&gt; {
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">g_to_univariate_at</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">at</span><span>: </span><span style="color:#b854d4;">usize</span><span>, </span><span style="color:#d73737;">point</span><span>: &amp;[F]) -&gt; DensePolynomial&lt;F&gt; {
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> fixed_1 = </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">fix_variables</span><span>(&amp;point[..at]);
</span><span>
</span><span>        </span><span style="color:#b854d4;">if</span><span> at != </span><span style="color:#d73737;">self</span><span>.f_a.</span><span style="color:#1fad83;">num_vars</span><span>() - </span><span style="color:#b65611;">1 </span><span>{
</span><span>            fixed_1.</span><span style="color:#1fad83;">relabel_inplace</span><span>(</span><span style="color:#b65611;">0</span><span>, fixed_1.</span><span style="color:#1fad83;">num_vars</span><span>() - </span><span style="color:#b65611;">1</span><span>, </span><span style="color:#b65611;">1</span><span>);
</span><span>            fixed_1 = fixed_1.</span><span style="color:#1fad83;">fix_variables</span><span>(&amp;[point[point.</span><span style="color:#1fad83;">len</span><span>() - </span><span style="color:#b65611;">1</span><span>]]);
</span><span>            </span><span style="color:#b854d4;">let</span><span> fixed_2 = fixed_1.</span><span style="color:#1fad83;">fix_variables</span><span>(&amp;point[at + </span><span style="color:#b65611;">1</span><span>..point.</span><span style="color:#1fad83;">len</span><span>() - </span><span style="color:#b65611;">1</span><span>]);
</span><span>            fixed_1 = fixed_2;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b854d4;">let</span><span> domain = GeneralEvaluationDomain::new(</span><span style="color:#b65611;">3</span><span>).</span><span style="color:#1fad83;">unwrap</span><span>();
</span><span>
</span><span>        </span><span style="color:#b854d4;">let</span><span> evaluations = domain
</span><span>            .</span><span style="color:#1fad83;">elements</span><span>()
</span><span>            .</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">e</span><span>| fixed_1.</span><span style="color:#1fad83;">evaluate</span><span>(&amp;[e]).</span><span style="color:#1fad83;">unwrap</span><span>())
</span><span>            .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>        </span><span style="color:#b854d4;">let</span><span> evaluations = Evaluations::from_vec_and_domain(evaluations, domain);
</span><span>
</span><span>        evaluations.</span><span style="color:#1fad83;">interpolate</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="testing-the-code">Testing the code.</h2>
<p>To test the code we need to use the $\mathbb{F}_p$ where $p$ is a prime
such that $p \geq 6n^3$. We are going to write a simple test for the
$4 \times 4$ matrix and the smallest $p$ satisfying this bound is $389$.</p>
<p>So lets construct the field, the adjacency matrix and kick off
the Sum Check protocol the same way we did in testing in the previous post:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#d73737;">test</span><span>]
</span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">test_simple_matrix</span><span>() {
</span><span>    #[</span><span style="color:#d73737;">derive</span><span>(MontConfig)]
</span><span>    #[</span><span style="color:#d73737;">modulus </span><span>= &quot;</span><span style="color:#60ac39;">389</span><span>&quot;]
</span><span>    #[</span><span style="color:#d73737;">generator </span><span>= &quot;</span><span style="color:#60ac39;">2</span><span>&quot;]
</span><span>    </span><span style="color:#b854d4;">struct </span><span>FrConfig;
</span><span>
</span><span>    </span><span style="color:#b854d4;">type </span><span>Fp389 = Fp64&lt;MontBackend&lt;FrConfig, 1&gt;&gt;;
</span><span>
</span><span>    </span><span style="color:#b854d4;">let</span><span> rng = &amp;</span><span style="color:#b854d4;">mut </span><span style="color:#1fad83;">test_rng</span><span>();
</span><span>
</span><span>    </span><span style="color:#b854d4;">let</span><span> adj_matrix = vec![
</span><span>        vec![</span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">false</span><span>],
</span><span>        vec![</span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">false</span><span>],
</span><span>        vec![</span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">true</span><span>, </span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">false</span><span>],
</span><span>        vec![</span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">false</span><span>, </span><span style="color:#b65611;">false</span><span>],
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b854d4;">let</span><span> g: G&lt;Fp389&gt; =
</span><span>        G::new_adj_matrix(adj_matrix.</span><span style="color:#1fad83;">len</span><span>(), adj_matrix.</span><span style="color:#1fad83;">iter</span><span>().</span><span style="color:#1fad83;">flatten</span><span>().</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">b</span><span>| *b));
</span><span>
</span><span>    </span><span style="color:#b854d4;">let</span><span> num_vars = g.</span><span style="color:#1fad83;">num_vars</span><span>();
</span><span>    </span><span style="color:#b854d4;">let mut</span><span> prover = Prover::new(g.</span><span style="color:#1fad83;">clone</span><span>());
</span><span>    </span><span style="color:#b854d4;">let c_1 </span><span>= prover.</span><span style="color:#1fad83;">c_1</span><span>();
</span><span>    </span><span style="color:#b854d4;">let mut</span><span> r_j = Fp389::one();
</span><span>    </span><span style="color:#b854d4;">let mut</span><span> verifier = Verifier::new(num_vars, </span><span style="color:#b854d4;">c_1</span><span>, g);
</span><span>
</span><span>    </span><span style="color:#b854d4;">for</span><span> j in </span><span style="color:#b65611;">0</span><span>..num_vars {
</span><span>        </span><span style="color:#b854d4;">let</span><span> g_j = prover.</span><span style="color:#1fad83;">round</span><span>(r_j, j).</span><span style="color:#1fad83;">unwrap</span><span>();
</span><span>        </span><span style="color:#b854d4;">let</span><span> verifier_res = verifier.</span><span style="color:#1fad83;">round</span><span>(g_j, rng).</span><span style="color:#1fad83;">unwrap</span><span>();
</span><span>        </span><span style="color:#b854d4;">match</span><span> verifier_res {
</span><span>            VerifierRoundResult::JthRound(r) =&gt; {
</span><span>                r_j = r;
</span><span>            }
</span><span>            VerifierRoundResult::FinalRound(res) =&gt; {
</span><span>                assert!(res);
</span><span>                </span><span style="color:#b854d4;">return</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    panic!(&quot;</span><span style="color:#60ac39;">should have returned on FinalRound from verifier</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>and when we run it hopefully we will see that it succeeds:</p>
<pre style="background-color:#fefbec;color:#6e6b5e;"><code><span>running 1 test
</span><span>test tests::test_simple_matrix ... ok
</span><span>
</span><span>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</span></code></pre>
<h2 id="final-notes">Final Notes</h2>
<p>The code for the implementation as always may be found in the <a href="https://github.com/montekki/thaler-study/tree/master/triangle-counting">repo</a>.
The existing approach to Sum Check protocol is not quite efficient yet
it has some obvious places to optimize as well as implement the optimizations
The Book talks about. However recall that <em>Premature optimization is the root of all evil</em>
and we were more focusing here on generalizing the protocol
to lay the foundation for the upcoming GKR implementation. For any
questions, suggestions or fixes just create an issue in the repo.
Thanks and see you in the next post.</p>
<hr />
<h2 id="changelog">Changelog</h2>
<p><code>26-08-2022</code></p>
<ul>
<li>Fixed <code>to_evaluations</code> function and added a randomized test. The changeset may
be found at <a href="https://github.com/montekki/thaler-study/commit/893317649e56ceee249ff9bc169e0e4b58f70a81"><code>8933176</code></a> in the repo.</li>
<li>Fixed typos and things pointed out in review by <a href="https://github.com/thor314">Thor</a>.</li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; <time datetime="2025-08-13T09:59:53.945522080+00:00">2022-2025</time> Fedor Sakharov. </span>
  </footer>
  
</body>
</html>
