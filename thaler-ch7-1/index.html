<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>A (Relaxed) PCS by Merkle Trees and Low-Degree Tests</title>



<meta property="og:title" content="A (Relaxed) PCS by Merkle Trees and Low-Degree Tests">



<meta name="author" content="Fedor Sakharov">


<meta property="og:locale" content="en_US">




<link rel="canonical" href="https://montekki.github.io/thaler-ch7-1/">
<meta property="og:url" content="https://montekki.github.io/thaler-ch7-1/">





  <meta property="og:image" content="https://montekki.github.io/assets/favicon.jpg">
  
  



  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-01-09T00:00:00+00:00">







  <meta name="twitter:card" content="summary_large_image"">
  <meta property="twitter:image" content="https://montekki.github.io/assets/favicon.jpg">



  <meta property="twitter:title" content="A (Relaxed) PCS by Merkle Trees and Low-Degree Tests">



  <meta name="twitter:site" content="@m0nt3kk1">
  






<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"Fedor Sakharov"
  },
  "description": "",
  "url": "https://montekki.github.io/thaler-ch7-1/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "A (Relaxed) PCS by Merkle Trees and Low-Degree Tests"
  
    
    
      "datePublished":"2023-01-09T00:00:00+00:00",
    
    ,
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://montekki.github.io/thaler-ch7-1/"
    }
  
}
</script>

  <link rel="stylesheet" href="https://montekki.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://montekki.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://montekki.github.io/assets/favicon-16x16.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://montekki.github.io/atom.xml" title="" />
  

  

  
  

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
                                                                                                                                                                                                            <script>


        document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
    </script>


</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://montekki.github.io">
        <h2 class="nav-title"></h2>
      </a>
      <ul>
        
          
            <li><a href="https://montekki.github.io">Blog</a></li>
          
            <li><a href="https://montekki.github.io/tags">Tags</a></li>
          
            <li><a href="https://montekki.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<time datetime="2023-01-09">January  9, 2023</time>
  	</div>
  	<h1 class="post-title">A (Relaxed) PCS by Merkle Trees and Low-Degree Tests</h1>
  	<div class="post-line"></div>
  	<p>Chapter three dives into a first Succinct Argument of Circuit
Satisfiability. It does so by introducing what it calls a Relaxed
Polynomial Commitment Scheme that combines Merkle Trees and
Low-Degree tests. Implementing a first Succinct Argument sounds
like an interesting challenge, let's find out.</p>
<span id="continue-reading"></span>
<p>In Chapter 7 The Books gives the main definitions and the motivations
for the new objects called Polynomial Commitment Schemes. Essentially
what we want is a scheme where $\mathcal{P}$ would "commit" to
the evaluations of some polynomial and its degree to be later tested
by $\mathcal{V}$.</p>
<h2 id="the-scheme">The Scheme</h2>
<p>The Scheme itself as it is quoting The Book:</p>
<blockquote>
<p>Let $\tilde{w} : \mathbb{F}^{\log n} \rightarrow \mathbb{F}$ be a
($\log n$)-variate multilinear polynomial over $\mathbb{F}$.</p>
<p>Let $s$ be the string consisting of all $|\mathbb{F}|^{\log n}$
evaluations of $\tilde{w}$.</p>
<p>One obtains a polynomial commitment scheme by applying a Merkle-tree
based string commitment scheme to $s$ and then applying a low-degree
test to $s$.</p>
</blockquote>
<p>Let's try to decompose it.</p>
<h3 id="merkelizing-the-evaluations">Merkelizing the Evaluations</h3>
<p>This is the easier part. Suppose for example that we have a function
$\mathbb{F_5}^2$. The evaluation table for this function would look
as follows:</p>
<table><thead><tr><th>0 0</th><th>0 1</th><th>0 2</th><th>..</th><th>5 4</th><th>5 5</th></tr></thead><tbody>
<tr><td>s[0]</td><td>s[1]</td><td>s[2]</td><td>..</td><td>s[23]</td><td>s[24]</td></tr>
</tbody></table>
<p>And in order for $\mathcal{P}$ to commit to all the evaluations of
this function it needs to create a Merkle Tree of $s$ and send
$\mathcal{V}$ the root of this tree. Later when $\mathcal{V}$ asks
$\mathcal{P}$ to reveal any of the evaluations, $\mathcal{P}$ replies
with the evaluation + a proof of this evaluation's inclusion into the
tree. Since merkelizing things is such a common theme in the blockchain
space I am not going to go into it any further.</p>
<h3 id="running-a-low-degree-test">Running a Low-Degree Test</h3>
<p>The explanation from The Book is a bit handwavy so it probably makes
sense to look into [AS03] paper:</p>
<p>The low degree test is presented with
$f:\mathbb{F}^m \rightarrow \mathbb{F}$ and an integer $d$. It is also
presented a table that is meant to be "proof" that $f$ is degree $d$
polynomial. This table contains for each line in $\mathbb{F}^m$ a
univariate degree $d$ polynomial that supposedly describes restriction
of $f$ to that line. We will use the term $\textit{d-oracle}$ for any table that
contains, for each line in $\mathbb{F}^m$ a univariate degree $d$
polynomial.</p>
<p>$$
\boxed{
\begin{aligned}
&amp;\text{\bf{The Low Degree Test:}}\cr
&amp;\text{Pick a random line } l \text{ in } \mathbb{F}^m\cr
&amp;\text{and read the univariate polynomial, say } p_l(t)\cr
&amp;\text{which the given \textit{d-oracle} contains for this line.}\cr
&amp;\text{Randomly pick a point $x$ on line $l$ and check}\cr
&amp;\text{whether $p_l$ correctly describes $f$ at $x$.}\cr
&amp;\text{If so, ACCEPT, else REJECT}
\end{aligned}
}
$$</p>
<p>The Test from the paper [AS03] is not interactive, and assumes the oracle
access to the whole $\textit{d-oracle}$ table. So here are a few ideas
to take this description to the PCS protocol from The Book:</p>
<ol>
<li>At the beginning of the protocol $\mathcal{P}$ commits to the Merkle
tree of the string of $f$ evaluations and to the claimed degree $d$
of $f$ by sending these values to $\mathcal{V}$.</li>
<li>$\mathcal{V}$ picks a random line $l$ in $\mathbb{F}^m$ and sends
it to $\mathcal{P}$.</li>
<li>$\mathcal{P}$ replies with a univariate polynomial $p_l$ which
it claims to be a restriction of $f$ to $l$.</li>
<li>$\mathcal{V}$ generates a random $x \in \mathbb{F}$. Then it
evaluates line $l$ on $x$ to obtain a point in $\mathbb{F}^m$.
$\mathcal{V}$ sends this point to $\mathcal{P}$ and $\mathcal{P}$
replies with a corresponding value from $s$ and with the proof this
evaluation's membership in the Merkle tree which was previously
committed to by $\mathcal{P}$.</li>
<li>$\mathcal{V}$ checks that $p_l(x)$ equals the received value from $s$
and that this value belongs to the Merkle tree.</li>
</ol>
<h2 id="implementation">Implementation</h2>
<p>Restricting a polynomial to a line has been described and implemented
in a <a href="https://montekki.github.io/thaler-ch4-4/">previous post on GKR</a>. What
we need is the machinery to merkelize the evaluations string $s$.</p>
<h3 id="all-values-of-mathbb-f">All Values of $\mathbb{F}$</h3>
<p>First we need to be able to evaluate our function $f$ on all values in $\mathbb{F}^m$.
It would be great to introduce a helper trait that would allow the code to iterate
over all possible values of $\mathbb{F}$:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#999580;">/// Iterate over all possible values of a finite field.
</span><span style="color:#b854d4;">pub trait </span><span>IF: Field {
</span><span>    </span><span style="color:#b854d4;">type </span><span>Values: IntoIterator&lt;Item = </span><span style="color:#b854d4;">Self</span><span>&gt;;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">all_values</span><span>() -&gt; </span><span style="color:#b854d4;">Self::</span><span>Values;
</span><span>}
</span></code></pre>
<p>Now in order to turn all values in $\mathbb{F}$ into all values in $\mathbb{F}^m$
we need to build all permutations of values in $\mathbb{F}$ of length $m$. Since building
such permutations is not the topic of this post the readily available code can be used to
extend the above trait with a helper function:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub trait </span><span>IF: Field {
</span><span>    </span><span style="color:#b854d4;">type </span><span>Values: IntoIterator&lt;Item = </span><span style="color:#b854d4;">Self</span><span>&gt;;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">all_values</span><span>() -&gt; </span><span style="color:#b854d4;">Self::</span><span>Values;
</span><span>
</span><span>    </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">all_multidimentional_values</span><span>(</span><span style="color:#d73737;">m</span><span>: </span><span style="color:#b854d4;">usize</span><span>) -&gt; Vec&lt;Vec&lt;</span><span style="color:#b854d4;">Self</span><span>&gt;&gt; {
</span><span>        </span><span style="color:#b854d4;">let mut</span><span> res: Vec&lt;_&gt; =
</span><span>            permutations::permutations(&amp;</span><span style="color:#b854d4;">Self</span><span>::all_values().</span><span style="color:#1fad83;">into_iter</span><span>().collect::&lt;Vec&lt;_&gt;&gt;(), m)
</span><span>                .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>        res.</span><span style="color:#1fad83;">sort</span><span>();
</span><span>        res
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="prover">Prover</h3>
<p>$\mathcal{P}$ is initialized with some polynomial $f$, our implementation as usual
is going to be quite generic. Here, it is being generic over a field $\mathbb{F}$,
the $f$ and the parameters of the Merkle tree:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">pub struct </span><span>Prover&lt;F: Field, M: MultilinearExtension&lt;F&gt;, P: Config&lt;Leaf = F&gt;&gt; {
</span><span>    </span><span style="color:#d73737;">tree</span><span>: MerkleTree&lt;P&gt;,
</span><span>    </span><span style="color:#d73737;">values_convenience_map</span><span>: HashMap&lt;Vec&lt;F&gt;, </span><span style="color:#b854d4;">usize</span><span>&gt;,
</span><span>    </span><span style="color:#d73737;">poly</span><span>: M,
</span><span>    </span><span style="color:#d73737;">values</span><span>: Vec&lt;F&gt;,
</span><span>}
</span></code></pre>
<p>The implementation allows any <code>MerkleTree</code> configuration to be used with only
restriction that the leafs of the tree have to be elements in $\mathbb{F}$.
Also <code>Prover</code> holds a convenience map from $\mathbb{F}^m$ to indices in the
evaluations string $s$.</p>
<p>Now to create a new $\mathcal{P}$ and populate all the fields in the above struct
a fairly involved logic has to be implemented:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: IF, M: MultilinearExtension&lt;F&gt;, P: Config&lt;Leaf = F&gt;&gt; Prover&lt;F, M, P&gt; {
</span><span>    </span><span style="color:#999580;">/// Create a new Prover.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">new</span><span>(
</span><span>        </span><span style="color:#d73737;">poly</span><span>: M,
</span><span>        </span><span style="color:#d73737;">leaf_chr_params</span><span>: &lt;&lt;P as Config&gt;::LeafHash as CRHScheme&gt;::Parameters,
</span><span>        </span><span style="color:#d73737;">two_to_one_params</span><span>: &lt;&lt;P as Config&gt;::TwoToOneHash as TwoToOneCRHScheme&gt;::Parameters,
</span><span>    ) -&gt; Result&lt;</span><span style="color:#b854d4;">Self</span><span>&gt; {
</span><span>        </span><span style="color:#b854d4;">let</span><span> all_values = F::all_multidimentional_values(poly.</span><span style="color:#1fad83;">num_vars</span><span>());
</span><span>        </span><span style="color:#999580;">// Populate s
</span><span>        </span><span style="color:#b854d4;">let</span><span> all_poly_values: Result&lt;Vec&lt;_&gt;&gt; = all_values
</span><span>            .</span><span style="color:#1fad83;">iter</span><span>()
</span><span>            .</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">value</span><span>| poly.</span><span style="color:#1fad83;">evaluate</span><span>(value).</span><span style="color:#1fad83;">ok_or</span><span>(Error::PolyEvalDimMismatch))
</span><span>            .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>        </span><span style="color:#b854d4;">let</span><span> all_poly_values = all_poly_values?;
</span><span>
</span><span>        </span><span style="color:#999580;">// Length of array for `MerkleTree` has to be a power of two, so
</span><span>        </span><span style="color:#999580;">// extend s with zeros up to that length.
</span><span>        </span><span style="color:#b854d4;">let</span><span> all_values_len = all_poly_values.</span><span style="color:#1fad83;">len</span><span>();
</span><span>        </span><span style="color:#b854d4;">let</span><span> values: Vec&lt;_&gt; = all_poly_values
</span><span>            .</span><span style="color:#1fad83;">iter</span><span>()
</span><span>            .</span><span style="color:#1fad83;">cloned</span><span>()
</span><span>            .</span><span style="color:#1fad83;">chain</span><span>((all_values_len..all_values_len.</span><span style="color:#1fad83;">next_power_of_two</span><span>()).</span><span style="color:#1fad83;">map</span><span>(|_| F::zero()))
</span><span>            .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>        </span><span style="color:#999580;">// Build a convenience indexing map
</span><span>        </span><span style="color:#b854d4;">let</span><span> values_convenience_map = all_values
</span><span>            .</span><span style="color:#1fad83;">iter</span><span>()
</span><span>            .</span><span style="color:#1fad83;">enumerate</span><span>()
</span><span>            .</span><span style="color:#1fad83;">map</span><span>(|(</span><span style="color:#d73737;">i</span><span>, </span><span style="color:#d73737;">value</span><span>)| (value.</span><span style="color:#1fad83;">clone</span><span>(), i))
</span><span>            .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>
</span><span>        </span><span style="color:#999580;">// Build a MerkleTree.
</span><span>        </span><span style="color:#b854d4;">let</span><span> tree: MerkleTree&lt;P&gt; =
</span><span>            MerkleTree::new(&amp;leaf_chr_params, &amp;two_to_one_params, values.</span><span style="color:#1fad83;">clone</span><span>())?;
</span><span>
</span><span>        Ok(</span><span style="color:#b854d4;">Self </span><span>{
</span><span>            tree,
</span><span>            poly,
</span><span>            values_convenience_map,
</span><span>            values,
</span><span>        })
</span><span>    }
</span><span>
</span><span>}
</span></code></pre>
<p>To complete the implementation of $\mathcal{P}$ three functions have to be added:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#999580;">/// Get the merkle root.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">merkle_root</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>) -&gt; </span><span style="color:#b854d4;">P::</span><span>InnerDigest {
</span><span>        </span><span style="color:#d73737;">self</span><span>.tree.</span><span style="color:#1fad83;">root</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#999580;">/// Restrict to line.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">poly_restriction_to_line</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">b</span><span>: &amp;[F], </span><span style="color:#d73737;">c</span><span>: &amp;[F]) -&gt; univariate::SparsePolynomial&lt;F&gt; {
</span><span>        </span><span style="color:#1fad83;">restrict_poly</span><span>(b, c, &amp;</span><span style="color:#d73737;">self</span><span>.poly)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#999580;">/// Challenge
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">challenge</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">point</span><span>: Vec&lt;F&gt;) -&gt; Result&lt;(Path&lt;P&gt;, F)&gt; {
</span><span>        </span><span style="color:#b854d4;">let</span><span> point_index = </span><span style="color:#d73737;">self</span><span>.values_convenience_map.</span><span style="color:#1fad83;">get</span><span>(&amp;point).</span><span style="color:#1fad83;">unwrap</span><span>();
</span><span>        Ok((
</span><span>            </span><span style="color:#d73737;">self</span><span>.tree.</span><span style="color:#1fad83;">generate_proof</span><span>(*point_index)?,
</span><span>            </span><span style="color:#d73737;">self</span><span>.values[*point_index],
</span><span>        ))
</span><span>    }
</span></code></pre>
<p>First one returns the root of the Merkle tree of $s$ $\mathcal{P}$ commits to at
the beginning of the protocol.</p>
<p>The second one restricts committed $f$ to a random line $x$ picked by $\mathcal{V}$.</p>
<p>The third one answers $\mathcal{V}$'s request to revel $s$ value at a given point
along with the proof of this value's membership in the committed Merkle tree.</p>
<h3 id="verifier">Verifier</h3>
<p>The $\mathcal{V}$ is going to hold quite a lot of data:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#999580;">/// The Verifier in the Relaxed PCS protocol.
</span><span style="color:#b854d4;">pub struct </span><span>Verifier&lt;F: Field, P: Config&lt;Leaf = F&gt;&gt; {
</span><span>    </span><span style="color:#d73737;">x</span><span>: F,
</span><span>    </span><span style="color:#d73737;">degree</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>    </span><span style="color:#d73737;">challenge_point</span><span>: Vec&lt;F&gt;,
</span><span>    </span><span style="color:#d73737;">line</span><span>: Vec&lt;univariate::SparsePolynomial&lt;F&gt;&gt;,
</span><span>    </span><span style="color:#d73737;">num_vars</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>    </span><span style="color:#d73737;">prover_univariate</span><span>: Option&lt;univariate::SparsePolynomial&lt;F&gt;&gt;,
</span><span>    </span><span style="color:#d73737;">merkle_root</span><span>: </span><span style="color:#b854d4;">P::</span><span>InnerDigest,
</span><span>    </span><span style="color:#d73737;">leaf_chr_params</span><span>: LeafParam&lt;P&gt;,
</span><span>    </span><span style="color:#d73737;">two_to_one_params</span><span>: TwoToOneParam&lt;P&gt;,
</span><span>}
</span></code></pre>
<p>When a new $\mathcal{V}$ is created it has to be initialized with the
values of degree $d$ and the root of the Merkle Tree of $s$ $\mathcal{P}$ has committed to:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b854d4;">impl</span><span>&lt;F: Field, P: Config&lt;Leaf = F&gt;&gt; Verifier&lt;F, P&gt; {
</span><span>    </span><span style="color:#999580;">/// Create a new Verifier.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">new</span><span>(
</span><span>        </span><span style="color:#d73737;">num_vars</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>        </span><span style="color:#d73737;">degree</span><span>: </span><span style="color:#b854d4;">usize</span><span>,
</span><span>        </span><span style="color:#d73737;">merkle_root</span><span>: </span><span style="color:#b854d4;">P::</span><span>InnerDigest,
</span><span>        </span><span style="color:#d73737;">leaf_chr_params</span><span>: &lt;&lt;P as Config&gt;::LeafHash as CRHScheme&gt;::Parameters,
</span><span>        </span><span style="color:#d73737;">two_to_one_params</span><span>: &lt;&lt;P as Config&gt;::TwoToOneHash as TwoToOneCRHScheme&gt;::Parameters,
</span><span>    ) -&gt; </span><span style="color:#b854d4;">Self </span><span>{
</span></code></pre>
<p>Then it picks the random line in $\mathbb{F}^m$ to send it to the $\mathcal{P}$.
To do so $\mathcal{V}$ generates two random points in $\mathbb{F}^m$ and uses the
function <code>line</code> implemented earlier for the GKR protocol:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">random_line</span><span>&lt;R: Rng&gt;(&amp;</span><span style="color:#b854d4;">mut </span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">rng</span><span>: &amp;</span><span style="color:#b854d4;">mut</span><span> R) -&gt; (Vec&lt;F&gt;, Vec&lt;F&gt;) {
</span><span>        </span><span style="color:#b854d4;">let</span><span> b: Vec&lt;F&gt; = (</span><span style="color:#b65611;">0</span><span>..</span><span style="color:#d73737;">self</span><span>.num_vars).</span><span style="color:#1fad83;">map</span><span>(|_| F::rand(rng)).</span><span style="color:#1fad83;">collect</span><span>();
</span><span>        </span><span style="color:#b854d4;">let</span><span> c: Vec&lt;F&gt; = (</span><span style="color:#b65611;">0</span><span>..</span><span style="color:#d73737;">self</span><span>.num_vars).</span><span style="color:#1fad83;">map</span><span>(|_| F::rand(rng)).</span><span style="color:#1fad83;">collect</span><span>();
</span><span>        </span><span style="color:#d73737;">self</span><span>.line = </span><span style="color:#1fad83;">line</span><span>(&amp;b, &amp;c);
</span><span>        (b, c)
</span><span>    }
</span></code></pre>
<p>When $\mathcal{P}$ has sent a univariate polynomial $p_l$ claimed to be a restriction
of $f$ to the line generated earlier, $\mathcal{V}$ checks its degree and saves to
evaluate it later:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">committed_univariate</span><span>(&amp;</span><span style="color:#b854d4;">mut </span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">p</span><span>: univariate::SparsePolynomial&lt;F&gt;) -&gt; Result&lt;()&gt; {
</span><span>        </span><span style="color:#b854d4;">if</span><span> p.</span><span style="color:#1fad83;">degree</span><span>() &gt; </span><span style="color:#d73737;">self</span><span>.degree {
</span><span>            </span><span style="color:#b854d4;">return </span><span>Err(Error::DegreeMismatch);
</span><span>        }
</span><span>        </span><span style="color:#d73737;">self</span><span>.prover_univariate = Some(p);
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<p>Then $\mathcal{V}$ needs to pick a random point along the picked line $l$ and send it
to $\mathcal{P}$ querying the corresponding value in $s$ along with the proof:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#999580;">/// Challenge the prover at some point.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">challenge_prover</span><span>&lt;R: Rng&gt;(&amp;</span><span style="color:#b854d4;">mut </span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">rng</span><span>: &amp;</span><span style="color:#b854d4;">mut</span><span> R) -&gt; Vec&lt;F&gt; {
</span><span>        </span><span style="color:#d73737;">self</span><span>.x = F::rand(rng);
</span><span>        </span><span style="color:#d73737;">self</span><span>.challenge_point = </span><span style="color:#d73737;">self
</span><span>            .line
</span><span>            .</span><span style="color:#1fad83;">iter</span><span>()
</span><span>            .</span><span style="color:#1fad83;">map</span><span>(|</span><span style="color:#d73737;">poly</span><span>| poly.</span><span style="color:#1fad83;">evaluate</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>.x))
</span><span>            .</span><span style="color:#1fad83;">collect</span><span>();
</span><span>        </span><span style="color:#d73737;">self</span><span>.challenge_point.</span><span style="color:#1fad83;">clone</span><span>()
</span><span>    }
</span></code></pre>
<p>Finally the $\mathcal{P}$'s reply has to be verified against the earlier
committed root of Merkle Tree of $f$ and also $\mathcal{V}$ needs to check
that value from $s$ $\mathcal{P}$ has replied with equals $p_l(x)$:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#999580;">/// Verify the prover&#39;s reply.
</span><span>    </span><span style="color:#b854d4;">pub fn </span><span style="color:#6684e1;">verify_prover_reply</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>, </span><span style="color:#d73737;">path</span><span>: Path&lt;P&gt;, </span><span style="color:#d73737;">leaf</span><span>: F) -&gt; Result&lt;()&gt; {
</span><span>        path.</span><span style="color:#1fad83;">verify</span><span>(
</span><span>            &amp;</span><span style="color:#d73737;">self</span><span>.leaf_chr_params,
</span><span>            &amp;</span><span style="color:#d73737;">self</span><span>.two_to_one_params,
</span><span>            &amp;</span><span style="color:#d73737;">self</span><span>.merkle_root,
</span><span>            leaf,
</span><span>        )?;
</span><span>
</span><span>        </span><span style="color:#b854d4;">let</span><span> eval = </span><span style="color:#d73737;">self
</span><span>            .prover_univariate
</span><span>            .</span><span style="color:#1fad83;">as_ref</span><span>()
</span><span>            .</span><span style="color:#1fad83;">ok_or</span><span>(Error::NoProverPoly)?
</span><span>            .</span><span style="color:#1fad83;">evaluate</span><span>(&amp;</span><span style="color:#d73737;">self</span><span>.x);
</span><span>        </span><span style="color:#b854d4;">if</span><span> leaf != eval {
</span><span>            </span><span style="color:#b854d4;">return </span><span>Err(Error::EvalMismatch(
</span><span>                format!(&quot;</span><span style="color:#b65611;">{:?}</span><span>&quot;, leaf),
</span><span>                format!(&quot;</span><span style="color:#b65611;">{:?}</span><span>&quot;, eval),
</span><span>            ));
</span><span>        }
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<h3 id="testing">Testing</h3>
<p>The testing code configures the Merkle Trees the same way testing code in
<a href="https://github.com/arkworks-rs/crypto-primitives/blob/release-0.4/src/merkle_tree/tests/mod.rs"><code>ark-crypto-primitives</code></a>
does with the only exception is that the implementation of <code>Config</code> is generic
over field $\mathbb{F}$ and uses a wrapper for a hasher to go from this generic
field type to bytes for hash convenience:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">type </span><span>LeafH = pedersen::</span><span style="color:#b65611;">CRH</span><span>&lt;JubJub, Window4x256&gt;;
</span><span>    </span><span style="color:#b854d4;">struct </span><span>CHROverField&lt;F&gt; {
</span><span>        </span><span style="color:#d73737;">__f</span><span>: PhantomData&lt;F&gt;,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b854d4;">impl</span><span>&lt;F: Field&gt; CRHScheme </span><span style="color:#b854d4;">for </span><span>CHROverField&lt;F&gt; {
</span><span>        </span><span style="color:#b854d4;">type </span><span>Input = F;
</span><span>
</span><span>        </span><span style="color:#b854d4;">type </span><span>Output = &lt;LeafH as CRHScheme&gt;::Output;
</span><span>
</span><span>        </span><span style="color:#b854d4;">type </span><span>Parameters = &lt;LeafH as CRHScheme&gt;::Parameters;
</span><span>
</span><span>        </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">setup</span><span>&lt;R: Rng&gt;(
</span><span>            </span><span style="color:#d73737;">r</span><span>: &amp;</span><span style="color:#b854d4;">mut</span><span> R,
</span><span>        ) -&gt; std::result::Result&lt;</span><span style="color:#b854d4;">Self::</span><span>Parameters, ark_crypto_primitives::Error&gt; {
</span><span>            LeafH::setup(r)
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b854d4;">fn </span><span style="color:#6684e1;">evaluate</span><span>&lt;T: Borrow&lt;</span><span style="color:#b854d4;">Self::</span><span>Input&gt;&gt;(
</span><span>            </span><span style="color:#d73737;">parameters</span><span>: &amp;</span><span style="color:#b854d4;">Self::</span><span>Parameters,
</span><span>            </span><span style="color:#d73737;">input</span><span>: T,
</span><span>        ) -&gt; std::result::Result&lt;</span><span style="color:#b854d4;">Self::</span><span>Output, ark_crypto_primitives::Error&gt; {
</span><span>            </span><span style="color:#b854d4;">let</span><span> bytes = to_uncompressed_bytes!(input).</span><span style="color:#1fad83;">map_err</span><span>(|_| Box::new(Error::ToBytesError))?;
</span><span>            LeafH::evaluate(parameters, bytes.</span><span style="color:#1fad83;">as_ref</span><span>())
</span><span>        }
</span><span>    }
</span></code></pre>
<p>This way in the config for the merkle tree the associated <code>Leaf</code> type can be our field
and not the <code>[u8]</code> slice:</p>
<pre data-lang="rust" style="background-color:#fefbec;color:#6e6b5e;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b854d4;">struct </span><span>JubJubMerkleTreeParamsFp5;
</span><span>
</span><span>    </span><span style="color:#b854d4;">impl </span><span>Config </span><span style="color:#b854d4;">for </span><span>JubJubMerkleTreeParamsFp5 {
</span><span>        </span><span style="color:#b854d4;">type </span><span>Leaf = Fp5;
</span><span>
</span><span>        </span><span style="color:#b854d4;">type </span><span>LeafDigest = &lt;LeafH as CRHScheme&gt;::Output;
</span><span>        </span><span style="color:#b854d4;">type </span><span>LeafInnerDigestConverter = ByteDigestConverter&lt;</span><span style="color:#b854d4;">Self::</span><span>LeafDigest&gt;;
</span><span>        </span><span style="color:#b854d4;">type </span><span>InnerDigest = &lt;CompressH as TwoToOneCRHScheme&gt;::Output;
</span><span>
</span><span>        </span><span style="color:#b854d4;">type </span><span>LeafHash = CHROverField&lt;Fp5&gt;;
</span><span>        </span><span style="color:#b854d4;">type </span><span>TwoToOneHash = CompressH;
</span><span>    }
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this a first Succinct Argument from The Book has been implemented.
The implementation is available at
<a href="https://github.com/montekki/thaler-study/commit/b73f65d33d5b00d19b286901ad754859d200337c"><code>b73f65d</code></a>.
As always the implementation has been made extremely generic over
everything and turned out quite good I believe. Thank you for reading
and stay tuned for the future posts!</p>
<hr />
<p>Reference List.</p>
<p><a href="https://www.youtube.com/watch?v=HQ9wTGBGNRU">YouTube: Log Degree Testing - Alessandro Chiesa</a></p>
<p><a href="http://people.csail.mit.edu/ronitt/papers/rs.pdf">Robust Characterizations of Polynomials with Applications to Program Testing</a></p>
<p><a href="http://people.csail.mit.edu/madhu/papers/1997/arora-conf.pdf">Improved Low-Degree testing and its applications</a></p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; <time datetime="2025-08-13T09:59:53.945123498+00:00">2022-2025</time> Fedor Sakharov. </span>
  </footer>
  
</body>
</html>
